package day;

public class Four {

	public static void main(String[] args) {

		/* 12.19 */
		/* <<추상화>> 
		 * 객체 지향 프로그래밍이란 현실세계의 모든 사건은 객체와 객체의 상호작용에 의해 일어난다는 세계관을
		 * 프로그래밍 언어에 적용한 것
		 * 무생물이나 개념 같은 존재도 하나의 주체가 가능하다는 게 현실과 다른 점
		 * 본인의 상태를 스스로 제어하고 행동한다??
		 * 모든 객체는 책임을 가지고 자신의 역할을 수행한다는 의미이기도 함
		 * 너무 많은 책임이 아니라 적절한 책임을 가지고 있어야 한다.
		 * 
		 * 추상화를 통해 복잡한 현실세계를 그대로 반영하지 않고 단순화한다. 
		 * (피라미드, 다단계???)
		 * 공통된 부분을 추출
		 * 
		 * 추상화의 목적
		 * 유연성 확보(여러 곳에 적용될 수 있는 유연한 객체 탄생)
		 * 이것은 재사용성 증가
		 * 재사용성 증가는 중복 코드 줄이고 오류 발생 가능성을 감소시켜 유지보수성을 증가시킨다.
		 * 
		 * 객체와 객체의 상호작용
		 * 수신자는 처리 방법을 스스로 결정해야 한다.
		 * 그 방법은 메소드.
		 * 속성(필드)는 부가적인 것이기 때문에 메소드를 중점으로 설계해야 한다
		 * 이렇게 설계하는 것을 추상화라고 한다.
		 * 
		 * VO(value object)
		 * 캡슐화의 원칙에는 어긋나나 추상화 하지 않는 객체
		 * 행위 위주x 데이터를 하나로 뭉치기 위한 값 객체
		 * 설정자와 접근자가 필드명을 그대로 사용하여 캡슐화의 원칙에 어긋남
		 * 미리 모든 필드의 접근 가능성을 염두해두고 작성하는 관례로 인해 현재도 많이 사용
		 * 
		 * 작성 방법
		 * 기본 생성자, 모든 필드를 초기화하는 생성자
		 * 필드는 private로 작성
		 * setter/getter
		 * toString 오버라이딩 
		 * 직렬화 (implements java.io.Serializable)
		 * 
		 * 직렬화는 뭐야?????
		 * 자바 시스템 내부에서 사용되는 Object 또는 Date를 외부의 자바 시스템에서도 사용할 수 있도록 
		 * byte 형태로 데이터를 변환하는 기술
		 * JVM의 메모리에 상주(힙 또는 스택)되어 있는 객체 데이터를 바이트 형태로 변환하는 기술
		 * 
		 * 접근자는 get으로 시작안하고 is로 바로 시작!
		 * 
		 * <<오버로딩>>
		 * public   void method() {}
		 * 접근제한자    반환형   메소드명       바디(몸체)
		 *                시그니처(method())
		 *          헤드(public~method())
		 *          
		 * 매개변수 선언부에 타입,개수,순서를 다르게 작성하면 서로 다른 메소드나 생성자로 인식
		 * 오버로딩
		 * 
		 * 사용이유
		 * 매개변수의 종류별로 메소드 내용이 달라야한다.
		 * 그러나 매개변수마다 이름을 다르게 만들면 복잡하고 관리가 어렵다
		 * 
		 * 오버로딩의 조건
		 * 시그니처 중 선언부가 다르게 작성되야 한다.
		 * 반환형과 접근제한자는 오버로딩 성립요건에 해당 x
		 * public void test(int num, int num2) {}
		 * private void test(String name, int num) {}
		 * 
		 * <<파라미터>>
		 * (파라미터)매개변수로 사용 가능한 자료형
		 * 1. 기본자료형
		 * 2. 기본자료형 배열
		 * 3. 클래스 자료형
		 * 4. 클래스 자료형 배열(객체 배열)
		 * 5. 가변인자
		 * 
		 * 가변인자 - 인자로 전달하는 값의 개수가 정해지지 않은 경우 가변 배열을 이용 가능
		 * 가변 배열을 매개변수로 이용한 메소드는 모호성으로 오버로딩을 하지 않는 것이 좋다
		 * 
		 * public void testPrimaryTypeArrayParameter(int[] arr) {}
		 * 
		 * 배열의 주소가 전달된다.
		 * 인자로 전달하는 배열과 매개변수로 전달받은 배열은 서로 동일한 배열을 가리킨다. 얕은복사다!!
		 * 인자는 값, 매개변수는 공간
		 * 공간 = 인자;
		 * 
		 * 클래스 자료형도 같다
		 * public void testClassTypeParameter(RectAngle rectAngle) {}
		 * 클래스 자료형도 마찬가지, 인자로 전달하는 인스턴스와 매개변수로 전달 받은 인스턴스는 서로 동일한 인스턴스를 가리킨다(얕은복사다)
		 * 이게 정말 중요하다... 이걸 이해 못해서 뒤에 내용에서 고생했다.
		 * 
		 * public void gabeon(String name, String...hobby) {}
		 * 가변길이의 배열은 몇 개가 매개변수로 전달될지 모르는 상황이기 때문에 뒤쪽에 작성해야 나머지 것들을 전부 받아 줄 수 있다.
		 * */

		/* <<final>>
		 * 필드 ( == 전역변수 == 속성 == 멤버변수
		 * 메소드 == 멤버함수
		 * 
		 * non-static field == 인스턴스변수
		 * static field == 정적필드 == 클래스 변수
		 * 
		 * final은 키워드는 변경 불가
		 * final은 선언하면서 초기화해야 컴파일 에러가 생기지 않는다.
		 * 
		 * 에러가 안 나는 방법
		 * 1. 선언과 동시에 초기화
		 * private final int NON_STATIC_NUM = 1;
		 * 
		 * 2. 생성자를 이용해서 초기화
		 * private final String NON_STATIC_NUM;
		 * public FinalFieldTest(String nonStaticName) {
		 *     this.NON_STATIC_NUM = nonStaticName;
		 * }
		 * 
		 * static final은?
		 * static에도 자바에서 정한 초기값이 대입
		 * 초기화 하지 않으면 에러
		 * 이것은 생성자를 이용한 초기화는 불가
		 * static은 생성자 이전에 만들어지기 떄문에 초기화 불가
		 *  
		 *  <<design pattern>>
		 *  singleton
		 *  인스턴스를 하나만 만들어도 됨, 그 하나의 인스턴스를 공유하여 사용해 메모리 낭비 방지
		 *  장점 : 1. 인스턴스를 생성하긴 해야하므로 다른 것과 비교해서 속도차이가 나지 않지만
		 *       그 다음부터는 이미 만들어진 인스턴스를 사용하므로 시간 낭비 없이 사용 가능
		 *       2. 인스턴스가 절대적으로 한 개만 존재하는 것을 보증할 수 있다 
		 *       왜??
		 *  단점 :
		 *       1. 너무 많은 일(많은 메소드와 필드)을 하거나 데이터를 공유하면 결합도가 높아진다.(유지보수 문제)
		 *       2. 동시성을 고려해야 하므로 설계 난이도가 있다.
		 *       * 동기화 하나의 스레드가 동작하여 접근할 때 다른 스레드는 접근을 막는 것
		 *   
		 *  싱글톤 구현 방법
		 *  1. 이른 초기화 eager initialization
		 *  2. 게으른 초기화 lazy initialization
		 *  
		 *  이른 초기화 - 클래스가 초기화 되는 시점에 인스턴스 생성(시작이 느리고 점점 빨라짐)
		 *  private static EagerSingleton eager = new EagerSingleton();
		 *  프로그램이 시작될 떼 static과 heap에 공간을 만들고 heap의 주소를 static이 보관
		 *  
		 *  싱글톤 패턴은 생성자 호출을 통해 외부에서 인스턴스 생성을 제한 private로
		 *  private EagerSingleton() {}
		 *  
		 *  public 인터페이스를 통해 인스턴스를 반환한다
		 *  public static EagerSingleton getInstance() {
		 *     return eager;
		 *     }
		 *  하나의 인스턴스만을 가지고 돌려쓸 수 있다.
		 *  EagerSingleton eager1 = EagerSingleton.getInstance();
		 *    
		 *  게으른 초기화
		 *  private static LazySingleton lazy;
		 *  우선 null 값으로  정적 필드 선언
		 *  
		 *  외부의 인스턴스 생성 제한
		 *  private LazySingleton() {}
		 *  public static LazySingleton getInstance() {
		 *      return lazy;
		 *  }
		 *  이렇게만 해노면 null 값만 반환
		 *   public static LazySingleton getInstance() {
		 *     if(lazy == null) {
		 *     lazy = new LazySingleton();
		 *  }
		 *      return lazy;
		 *  }
		 *  lazy 값이 null인 경우에 인스턴스를 한 번 생성한다. 그 다음부터는 만들어진 주소값을 반환
		 *  
		 *  LazySingleton lazy1 = LazySingleton.getInstance();
		 *  lazy는 처음 시작은 빠르나 생성할 때는 느려진다.
		 *  
		 *  프로그램 시작시 인스턴스를 만드냐? 호출할 때 인스턴스를 만드느냐의 차이다.
		 * 
		 *  # 7. 변수의 종류

                         클래스는 패키지 선언부, 클래스 선언부, 클래스 영역, 필드, 메소드 영역 등으로 이루어져 있다
                         클래스의 접근 제한자는 public, default만 가능
             public class 는 파일 이름과 같은 클래스에만 사용 가능            
                         매개변수도 일종의 지역변수
                         
             # 8. 초기화 블럭

- 복잡한 초기식을 수행할 수 있는 블럭 제공, 인스턴스 초기화 블럭과 정적 초기화 블럭으로 구현

---

## 8-1 인스턴스 초기화 블럭

- 인스턴스가 생성되는 시점에 (생성자 호출 이전에) 먼저 실행
- 인스턴스를 생성하는 시점마다 호출
- 인스턴스 변수를 초기화하며 정적필드에는 실행시점마다 값을 덮어쓴다

{  초기화 내용 작성   }

---

## 8-2 정적 초기화 블럭

- 클래스가 로드될 때 한 번 동작
- 정적 초기화 블럭은 로드 시 동작하므로 인스턴스가 존재할 수 없다.
- 정적 필드를 초기화, 인스턴스 변수는 초기화x

static (  초기화 내용 작성  }

---

## 8-3 초기화 순서

- 인스턴스 변수 : 기본값 - 명시적초기화 - 인스턴스 초기화 블럭 - 생성자
- 클래스 변수 : 기본값 - 명시적초기화 - 정적 초기화 블럭 - 인스턴스 초기화 블럭 - 생성자
		 *  */
	}

}
