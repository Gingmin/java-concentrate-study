package day;

public class five {

	public static void main(String[] args) {

		/*
		12.20
		
		<< 객체 배열 >>
		객체배열은 인스턴스의 배열이다
		반복문을 사용해서 처리할 수 있어서 유용하다
		반환값은 1개의 값만 반환 가능하니까 동일한 타입의 인스턴스를 반환해야 하는 경우 좋다
		Car[] carArray = new Car[5];
		
		<< 상속 >>
		부모의 재산(멤버)를 물려 받는다는 의미
		하지만 물려받는다는 의미보다 정확한 건 확장(extend)의 개념
		오버라이딩도 가능
		생성자는 상속 불가
		
		장점
		1. 작성한 클래스 재사용(생산성 향상)
		 공통 코드가 부모 클래스에 있다면 부모클래스만 수정해도 된다 (유지보수성)
		2. 다형성 문법적 토대
		
		단점
		1. 부모(선조, 슈퍼, 조상)클래스에 기능을 추가/변경하면 자식클래스(서브, 후손, 파생)가 정상적으로 동작하는지 예측이 힘듬, 유지보수성에 악영향을 줄 수 있다.
		2. 부모클래스의 변경이 쉽지 않다.(자식클래스에서 중요하게 사용할 수 있으므로)
		3. 부모클래스에서 의미있는 기능이 자식클래스에서는 무의미 할 수 있다(불필요한 기능이 추가됨)

		단점과 장점이 공존하기 때문에 IS-A관계일때만 사용해라
		FireCar is a Car(0) / Car is a FireCar(x)
		
		super super()
		자식클래스를 이용해서 객체를 생성할 때 부모생성자를 호출하여 부모클래스의 인스턴스도 함께 생성한다.
		부모의 인스턴스 주소를 보관하는 레퍼런스 변수가 super
		super()는 부모 생성자를 호출하는 구문
		this()가 해당 클래스의 내의 다른 생성자를 호출하는 구문이라면 super()는 부모클래스가 가지는 private생성자를 제외한
		나머지 생성자를 호출할 수 있도록한 구문
		
		
		오버라이딩(재작성)
		부모클래스에서 상속받은 메소드를 자식 클래스에서 재정의하여 사용하는 것
		@Override 어노테이션
		JDK 1.5부터 추가된 문법으로 오버라이딩 성립 요건을 체크해준다.
		
		오버라이딩 성립요건
		메소드 이름이 동일
		리턴 타입 동일
		매개변수의 타입, 개수, 순서가 동일
		private, final 오버라이딩 불가
		부모 클래스와 같거나 더 넓은범위로 오버라이딩 가능
		같은 예외이거나 더 구체적인 예외를 처리해야 함
		
		오버로딩
		리턴 타입과 접근제한자는 상관없음
		매개변수의 타입, 개수, 순서가 달라야함
		메소드 이름이 동일해야하는 것은 똑같다. */
	}

}
